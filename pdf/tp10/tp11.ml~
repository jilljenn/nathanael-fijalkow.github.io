let rec list_map f = function
  | [] -> []
  | h::t -> (f h)::list_map f t;;

let rec list_select p = function
  | [] -> []
  | h::t -> if p h then h::list_select p t else list_select p t;;

let rec ajoute e = function
  | [] -> [e]
  | h::t -> if e < h then e::h::t else h::(ajoute e t);;

let rec tri_insertion = function
  | [] -> []
  | h::t -> let l = tri_insertion t in ajoute h l;;

let rec tri_rapide list = 
  let rec split e = function
    | [] -> [],[]
    | h::t -> let l1,l2 = split e t in 
	if h < e then (h::l1,l2) else (l1,h::l2)
  in match list with
    | [] -> []
    | h::t -> let l1,l2 = split h t in 
	(tri_rapide l1)@(h::(tri_rapide l2)) ;;

let list_rev list =
  let rec boucle accu = function
    | [] -> accu
    | h::t -> boucle (h::accu) t 
      in boucle [] list ;;

let rec puissance x n =
  if n = 0 then 1
  else if n = 1 then x
  else let y = puissance x (n/2) in
    if n mod 2 = 0 then y * y else y * y * x;;

let rec pgcd x y =
  if y = 0 then x else pgcd y (x mod y) ;;

let rec base x b = 
  if x = 0 then []
  else if x < b then [x]
  else (x mod b)::(base (x/b) b) ;;

let rec eval_base b = function
  | [] -> 0
  | h::t -> h + b*(eval_base b t) ;;

let addition b x y = 
  let rec boucle x y r = match (x,y) with
    | [],[] -> if r = 0 then [] else [1]
    | hx::tx,[] -> let vl = hx + r in (vl mod b)::(boucle tx [] (if vl < b then 0 else 1))
    | [],hy::ty -> let vl = hy + r in (vl mod b)::(boucle [] ty (if vl < b then 0 else 1))
    | hx::tx,hy::ty -> let vl = hx + hy + r in
      (vl mod b)::(boucle tx ty (if vl < b then 0 else 1))
  in boucle x y 0;;

let fibo n =
  let rec boucle u v n = 
    if n = 0 then u else boucle v (u+v) (n-1)
  in boucle 0 1 n ;;

let rec eval a = function
  | [] -> 0
  | h::t -> h + a * (eval a t);;

let derive poly = 
  let rec boucle k = function
  | [] -> []
  | h::t -> (k*h)::(boucle (k+1) t)
  in match poly with
    | ([] | [_]) -> []
    | _::t -> boucle 1 t ;;

let translate poly = 
